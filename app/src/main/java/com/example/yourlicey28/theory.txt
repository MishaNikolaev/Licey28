1 - Разработка приложения на Android с использованием Jetpack Compose и архитектуры MVI (Model-View-Intent)
включает в себя несколько ключевых компонентов: ViewModel,
состояние (State), события (Event - связано с Intent) и интерфейс (UI).


2 - Определение состояния (State):
Состояние - это класс, который отражает все необходимые данные для отображения UI.
Например, для экрана списка пользователей:

Вот пример такой реализации:

data class UserListState(
    val isLoading: Boolean = false,
    val users: List<User> = emptyList(),
    val error: String = ""
)

3 - События
это действия, которые пользователь может выполнить. Например, загрузка списка пользователей:

sealed class UserListEvent {
    object LoadUserList : UserListEvent()
    // Другие события...
}

4 - ViewModel содержит логику обработки событий и обновления состояния.
Она также предоставляет состояние для UI.

class UserListViewModel : ViewModel() {
    private val _state = mutableStateOf(UserListState())
    val state: State<UserListState> = _state

    init {
        onEvent(UserListEvent.LoadUserList)
    }

    fun onEvent(event: UserListEvent) {
        when (event) {
            is UserListEvent.LoadUserList -> {
                // Загрузить список пользователей
            }
        }
    }
}

4 - UI отображает состояние и отправляет события в ViewModel.

@Composable
fun UserListScreen(viewModel: UserListViewModel = viewModel()) {
    val state = viewModel.state.value

    if (state.isLoading) {
        // Отображение индикатора загрузки
        ProgressBar
    } else if (state.error.isNotEmpty()) {
        // Отображение ошибки
    } else {
        // Отображение списка пользователей
    }
}


# Различия MVVM и MVI
MVVM (Model-View-ViewModel) и MVI (Model-View-Intent) — это два архитектурных паттерна,
используемых в разработке Android-приложений. Оба предназначены для упрощения и структурирования кода,
но они делают это по-разному.

--------------------------
MVVM (Model-View-ViewModel)
Компоненты:

Model: Содержит бизнес-логику и данные. Это может быть база данных, удаленный сервер и т.д.
View: Пользовательский интерфейс (UI). Это экраны, которые видит пользователь.
ViewModel: Слой, который связывает View и Model. Он отвечает за обработку данных из Model для отображения в View.
Как работает:

View запрашивает данные у ViewModel.
ViewModel получает данные из Model и преобразует их для отображения.
View обновляется данными, предоставленными ViewModel.
Пример:
Представьте ситуацию, где вы создаете приложение со списком задач.

Model содержит данные о задачах.
View — это экран с отображением задач.
ViewModel берет данные о задачах, возможно, форматирует их (например, сортирует) и отправляет в View.

----------------------
MVI (Model-View-Intent)
Компоненты:

Model: Также содержит бизнес-логику и данные.
View: Пользовательский интерфейс.
Intent: Это не часть UI, а скорее набор инструкций, которые описывают, что пользователь хочет сделать (например, загрузить данные, обновить элемент и т.д.).
Как работает:

View отправляет Intent о том, что нужно сделать.
Этот Intent обрабатывается, и в соответствии с ним Model изменяется или запрашивает новые данные.
Model отправляет обновленные данные обратно в View.
Пример:
В том же приложении со списком задач:

View отправляет Intent, например, "добавить новую задачу".
Этот Intent обрабатывается, в результате чего Model обновляется новой задачей.
Model отправляет обновленный список задач обратно в View.

-------
Отличия
Поток данных: В MVVM поток данных однонаправленный (от Model к View через ViewModel),
в то время как в MVI он более циклический (от View к Model и обратно).
Роль ViewModel/Intent: В MVVM, ViewModel активно преобразует данные для View, в MVI,
Intent определяет, какие действия должны быть выполнены.
Состояние приложения: MVI часто работает с неизменяемым состоянием, что может упростить отслеживание изменений и отладку.
Оба паттерна полезны и могут быть эффективно использованы в зависимости от конкретных требований и предпочтений разработчика.
MVVM часто считается более простым для начинающих,
в то время как MVI предлагает более строгий контроль над потоком данных и состоянием приложения.


1 - Domain создаешь data class с данными для показа на экране
2 - В файл Api надо добавить запрос который возвращает ответ как в документации api
3 - Interface Repository: добавляем функцию или функции чтобы переопределить в RepositoryImpl
4 - Создаем Screen, State, Event, Viewmodel
5 - в State создаешь переменные которые отвечают за состояние экрана (Данные которые показываешь юзеру)
6 - в Event создаешь события которыя должны происходить на экране
7 - Viewmodel вызываешь функции из Repository
8 - Делаешь дизайн экрана и экран всегда принимает state и processEvent
9 - В навигации создаешь composable для экрана , инициализируешь viewmodel и сам Screen

Flow в контексте Kotlin и Jetpack Compose относится к асинхронному потоку данных,
который может эмитировать несколько значений последовательно,
в отличие от одиночного значения или промиса. Он используется для представления асинхронных данных,
которые могут изменяться со временем, и поддерживает различные операции, такие как фильтрация,
преобразование и сбор значений. Flow часто используется в Kotlin для реактивного программирования,
облегчая работу с асинхронными потоками данных в приложениях.

В контексте Jetpack Compose, который является современной библиотекой UI от Google для Android,
разработчики могут использовать Flow для создания реактивного пользовательского интерфейса,
который автоматически обновляется при изменении данных.
Flow может быть интегрирован в Jetpack Compose с помощью collectAsState(),
который преобразует асинхронные потоки данных Flow в состояние,
которое можно использовать в Composable функциях для динамического отображения данных.